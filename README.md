# Сервис курьеров (Avito course)

Существует 2 способа запуска приложения:
1. Локально: через docker-compose.local.yaml. Через докер подтягивается бд и миграции, а сервис запускается локально через make
```bash
make up_local
```

1. Локально, но по-другому: через docker-compose.prod.yaml. Все то же самое, сам сервис подтягивается с моего DockerHub.
```bash
make up_prod
```
В целом, есть еще команды для остановки, они описаны в Makefile.

Из нового:
Добавил ручку DELETE. Сигнатура такая же как и у GET{id}.
Все правки правил.
К сожалению, уже нет сил на нормальный README, поэтому как-нибудь в другой раз сделаю.

Идеи:
1. Анврапп ошибок через Factory
2. Перед Update узнавать есть ли такой курьер
3. Запретить удалять курьера, который на активном заказе (чтобы потом не было проблем с удалением заказа у несуществующего курьера)
4. Использовать Strings.Builder при динамическом создании запроса

Вопросы:
1. Лучше передавать объекты domain/dto между слоями по указателям или явно копируя?

Что сделано (дз4):
1. добавлены миграции для новой таблицы delivery и нового поля transport_type в таблице couriers
2. дописан функционал ручек Get, GetAll, Post, Put, под работу с новым полем transport_type
3. реализованы новый репозиторий deliveryRepositoryPostgres для работы с delivery
и сервис deliveryService отвечающий за доставку.
4. deliveryService использует transaction manager для обеспечения атомарности проводимых операций.
А так же фабрику DeliveryTimeCalculator, для динамического определения дедлайна доставки в зависимости от типа траспорта курьера.
5. новые ручки POST /delivery/assign и POST /delivery/unassign

Что сделано (дз5):
1. в internal/worker создан deliveryMonitorWorker,
который реализует логику наблюдения за актуальностью заказа (условие истечения дедлайна)
Воркер активируется по тикеру и внедрен в логику graceful shutdown.
2. Курьеры теперь назначаются по принципу наименьшего количества выполненных заказов.
3. в таблице couriers новое поле total_deliveries

Что сделано (дз6)
1. Написаны unit тесты для контроллеров (100% покрытие)
2. Написаны unit тесты для сервисов (100% покрытие) 
пишет что покрытие 93-96 процентов, хотя по coverage.out видно, что это какой-то баг и на самом деле все покрыто
3. Написаны интеграционные тесты для репозиториев

чтобы запустить unit тесты
```bash
make run_tests
```
либо с выводом покрытия
```bash
make run_tests_with_coverage
```

для интеграционных тестов
```bash
make run_test_integration
```
тут поднимается тестовая бд, выполняются тесты и потом удаляется volume.